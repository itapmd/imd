---
title: Compilation Options
---

{% include imdhead.html %}

<h1>Compilation Options</h1>

<p>In addition to selecting the <a href="ensembles.html">simulation
ensemble</a> (i.e., the MD integrator), various options can be
compiled into IMD. Some options can be part of the 
<a href="compiling.html">compilation target</a>, others can only be
invoked by <a href="compiling.html">preprocessor flags</a>. </p>

<p>We give here a list of all possible options, and describe what
their purpose is and how they are used.</p>

<h2>Possible Options in the Compilation Target</h2>

<table border="0" cellpadding="4" summary="links to options">
<tr align="left">
<td width="120"><a href="#twod">2d</a></td>
<td width="120"><a href="#fourpoint">4point</a></td>
<td width="120"><a href="#atdist">atdist</a></td>
<td width="120"><a href="#avpos">avpos</a></td>
<td width="120"><a href="#ada">ada</a></td>
<td width="120"><a href="#cna">cna</a></td>
<td width="120"><a href="#corr">corr</a></td>
</tr>

<tr align="left">
<td width="120"><a href="#debug">debug</a></td>
<td width="120"><a href="#deform">deform</a></td>
<td width="120"><a href="#diffpat">diffpat</a></td>
<td width="120"><a href="#disloc">disloc</a></td>
<td width="120"><a href="#dsf">dsf</a></td>
<td width="120"><a href="#eam">eam</a></td>
</tr>

<tr align="left">
<td width="120"><a href="#eeam">eeam</a></td>
<td width="120"><a href="#efilter">efilter</a></td>
<td width="120"><a href="#einstein">einstein</a></td>
<td width="120"><a href="#epitax">epitax</a></td>
<td width="120"><a href="#ewald">ewald</a></td>
<td width="120"><a href="#fbc">fbc</a></td>
</tr>

<tr align="left">
<td width="120"><a href="#fnorm">fnorm</a></td>
<td width="120"><a href="#hpo">hpo</a></td>
<td width="120"><a href="#homdef">homdef</a></td>
<td width="120"><a href="#covalent">keating</a></td>
<td width="120"><a href="#laser">laser</a></td>
<td width="120"><a href="#laseryz">laseryz</a></td>
<td width="120"><a href="#loadbalance">loadbalance</a></td>
</tr>

<tr align="left">
<td width="120"><a href="#mono">mono</a></td>
<td width="120"><a href="#monolj">monolj</a></td>
<td width="120"><a href="#msqd">msqd</a></td>
<td width="120"><a href="#nbl">nbl</a></td>
<td width="120"><a href="#nnbr">nnbr</a></td>
<td width="120"><a href="#nye">nye</a></td>
<td width="120"><a href="#ordpar">ordpar</a></td>
</tr>

<tr align="left">
<td width="120"><a href="#pdecay">pdecay</a></td>
<td width="120"><a href="#nmoldyn">nmoldyn</a></td>
<td width="120"><a href="#pacx">pacx</a></td>
<td width="120"><a href="#pair">pair</a></td>
<td width="120"><a href="#prof">prof</a></td>
<td width="120"><a href="#quasi">quasi</a></td>
</tr>

<tr align="left">
<td width="120"><a href="#rigid">rigid</a></td>
<td width="120"><a href="#single">single</a></td>
<td width="120"><a href="#sock">sock</a></td>
<td width="120"><a href="#shock">shock</a></td>
<td width="120"><a href="#covalent">stiweb</a></td>
<td width="120"><a href="#stress_tens">stress</a></td>
</tr>

<tr align="left">
<td width="120"><a href="#covalent">tersoff</a></td>
<td width="120"><a href="#covalent">tersoff2</a></td>
<td width="120"><a href="#timing">timing</a></td>
<td width="120"><a href="#transport">transport/nvx</a></td>
<td width="120"><a href="#covalent">ttbp</a></td>
<td width="120"><a href="#uniax">uniax</a></td>
</tr>

<tr align="left">
<td width="120"><a href="#writef">writef</a></td>
<td width="120"><a href="#fefl">fefl</a></td>
<td width="120"><a href="#clone">clone</a></td>
<td width="120"><a href="#ep">ep</a></td>
<td width="120"><a href="#neb">neb</a></td>
<td width="120"><a href="#rnemd">rnemd</a></td>
</tr>

<tr align="left">
<td width="120"><a href="#sm">sm</a></td>
<td width="120"><a href="#viscous">viscous</a></td>
<td width="120"><a href="#zapp">zapp</a></td>
<td width="120"><a href="#"></a></td>
<td width="120"><a href="#"></a></td>
<td width="120"><a href="#"></a></td>
<td width="120"><a href="#"></a></td>
<td width="120"><a href="#"></a></td>
</tr>
</table>

<dl>

<dt><a id="twod" name="twod"><b>2d</b></a></dt>
<dd>
<p>
2d simulation rather than 3d. The option 3d also exists - it is
the default. </p>
</dd>

<dt><a id="cna" name="cna"><b>cna</b></a></dt>
<dd>
<p>
This option enables IMD to perform the <b>Common-Neighbour
Analysis</b> (CNA) during a simulation. The CNA is done in the same
way as in the utility program <a
href="util_config.html#imd_cna">imd_cna</a>.
</p>

<p>
The CNA starts at step <tt>cna_start</tt> (default: 0) and ends at
<tt>cna_end</tt> (default: <tt>maxsteps</tt>). The CNA is performed
every <tt>cna_int</tt> steps. The nearest neighbour distance for
common neighbours must be given by the parameter <tt>cna_rcut</tt>.
Using the parameter <tt>cna_write</tt>, a list of (up to eight)
four-digit pair types
<i>ijkl</i> can be given. Atoms belonging to these pair types are
written to the files
<tt>&lt;outfiles&gt;.&lt;n&gt;.&lt;<i>ijkl</i>&gt;.cna</tt>.
</p>

<p>
For fcc-like crystal structures, the option <b>cna</b> enables IMD to 
write atoms belonging to a specific crystallinity into files 
<tt>&lt;outfiles&gt;.&lt;n&gt;.crist</tt> which are written every 
<tt>cna_int</tt> steps. Four types of crystallinity can be selected:<br/>

<p>
<table border=0 cellpadding=4>
<tr>
<td>0</td>
<td>atoms belonging to the fcc structure</td>
</tr>
<tr>
<td>1</td>
<td>atoms belonging to the hcp structure</td>
</tr>
<tr>
<td>2</td>
<td>12-fold coordinated atoms not belonging to the fcc or hcp structure</td>
</tr>
<tr>
<td>3</td>
<td>not 12-fold coordinated atoms</td>
</tr>
</table>
</p>

<p>
Using the parameter <tt>cna_crist</tt>, a list of up to four types of 
crystallinity can be given. The format of the .crist files is the one
of IMD configuration files where the 10th column represents the type of 
crystallinity.
</p>

<p>
<b>Note:</b> The writing of .cna files is disabled when the parameter
<tt>cna_crist</tt> is used.
</p>

</dd>

<dt><a id="rigid" name="rigid"><b>rigid</b></a></dt> 
<dd> 
<p> 
This option enables IMD to combine atoms of one or several virtual
types into <i>superatoms</i> that behave like rigid bodies. Superatoms
are defined in the parameter file with the IMD parameter
<tt>rigid</tt> in the following form:</p>
<pre>
	rigid v_1 v_2 ... v_n  i j (k) 
</pre>
<p>Here, <tt>v_1</tt>, <tt>v_2</tt>, ..., <tt>v_n</tt>
(n<=<tt>total_types</tt>) are virtual types that are combined into a
superatom. The integers <tt>i</tt>, <tt>j</tt>(, <tt>k</tt>) take on
the values 0 or 1. They define a restricted motion of the atoms of the
superatoms. For example, in a 3d simulation, <tt>1 0 1</tt> means
rigid motion in <i>x</i> and <i>z</i> direction while in <i>y</i>
direction, the constituent atoms of the superatom can move
freely. Hence, <tt>1 1 1</tt> means complete rigidity and 
<tt>0 0 0</tt> no rigidity at all (no superatom).</p>

<p> It is possible to
define up to <tt>total_types</tt> different (nonintersecting)
superatoms.</p>

<p><b>Note:</b>Only translational motion of the superatoms is
possible; rotational motion is suppressed.<br /> The option <b>rigid</b>
is currently implemented only for the ensembles nve, mik, and nvt.</p>

</dd>

<dt><a id="nbl" name="nbl"><b>nbl</b></a></dt>
<dd>
<p>
This option enables the usage of <b>neighbor lists</b>, which can
be reused for a certain number of steps. The neighbor list of an 
atom includes the indices (cell and atom number within cell) of all 
those atoms, whose distance at the moment of creation of the 
list is within the interaction cutoff radius, or exceeds it by not 
more than <tt>nbl_margin</tt> (which is a parameter). The neighbor 
lists include all interacting particles, and thus remain valid, 
as long as no atom has moved by more than <tt>nbl_margin</tt>. 
If this is no longer the case, the neighbor lists are recomputed.
The advantage of neighbor lists is, that the number of atom pairs
for which the distance has to be computed is reduced by up to a
factor 6, which substantially reduces the computation time (
by up to 40%). The disadvantage is, that neighbor lists require a 
considerable amount of memory, which is why they are made optional.
The speedup depends on the value of <tt>nbl_margin</tt>. The larger
it is, the longer the neighbor list remains valid - and the more
distances have to be computed at each step. A value of some 15%
of a typical nearest neighbor distance seems to be a good starting
point. The neighbor list then has to be recomputed every 10-20
steps.</p>

<p>
The maximal number of atom pairs in the neighbor list is determined
as a rough estimate times a factor <tt>nbl_size</tt>, a parameter 
which defaults to <tt>1.1</tt>. If the neighbor list turns out to 
be too small, IMD aborts with an error message. This may happen if
the density of the system increases significantly, e.g. in an 
NPT simulation. In such a case, <tt>nbl_size</tt> can be set
to a larger value, like <tt>1.2</tt>. Note that the memory
requirement is directly proportional to <tt>nbl_size</tt>.

<p>
<b>Limitations:</b> Neighbor lists are currently implemented only
in <b>3d</b>, and only for <a href="pairpot.html">pair</a> and 
<a href="eam.html">EAM</a> interactions. In principle, they 
could also be implemented in 2d and for angle-dependent interactions,
but for these the benefit is less important (neighbor lists are 
already in use for some parts of the computation). 
<a href="epitax.html">Epitax</a> is also <b>not</b> supported with 
neighbor lists - they make little sense, if the number of particle 
can change at any time.
</p>
</dd>

<dt><a id="nmoldyn" name="nmoldyn"><b>nmoldyn</b></a></dt>
<dd>
<p>
<a href="http://dirac.cnrs-orleans.fr/nMOLDYN/">nMoldyn</a> is a 
postprocessor which computes from an MD trajectory various correlation
functions, especially ones which can be measured by inelastic neutron
scattering. The functionality of nMoldyn is described in J. Comput. Chem. 
<b>24</b>, 657-667 (2003). The option <b>nmoldyn</b> enables IMD to
write an MD trajectory to a single file, which can subsequently be
converted with the utility program 
<a href="util_correl.html#nmoldyn">imd2nc.py</a> to the netCDF format
required by nMoldyn.</p>

<p>
IMD writes every <tt>nmoldyn_int</tt> timesteps a configuration to 
the <tt>.nmoldyn</tt> trajectory file. The writing interval determines
the maximal frequency available in the correlation functions, whereas
the length of the trajectory determines the lowest frequency. It is
usually not required to write at every step, but only every 10 steps 
or so, depending on the frequency range required. If the flag 
<tt>nmoldyn_veloc=1</tt>, the velocities are also included in the 
trajectory file, otherwise they are computed numerically from the
positions. This is accurate enough only for very small values of
<tt>nmoldyn_int</tt>. For larger <tt>nmoldyn_int</tt> it is 
recommended to write also the velocities (this is the default).</p>

<p>
The nMoldyn trajectory files can get rather large. Especially for
single particle correlation functions it is not necessary to have
the trajectories of all atoms, but only those of a representative 
subset. For this reason, IMD writes only atoms with virtual types
smaller than <tt>ntypes</tt> to the trajectory file. By giving part
of the atoms larges virtual types, excessively large trajectory
files can be avoided.</p>

<p>
<strong>Note:</strong> With the nmoldyn option, the atoms must be
numbered such, that with increasing number the virtual type does not
decrease (i.e., smaller virtual types come first). Moreover, the
numbering must start at zero, and must have no gaps.
</p>
</dd>

<dt><a id="dsf" name="dsf"><b>dsf</b></a></dt>
<dd>
<p>
The option <b>dsf</b> allows to compute the dynamical structure factor
in an MD simulation, using an NVE integrator. Every <tt>dsf_int</tt> 
steps, IMD computes the spacial Fourier transform for a number of 
k-vectors, and writes it to a <tt>.dsf</tt> File. The value of
<tt>dsf_int</tt> determines the maximal frequency in the resulting
time series, whereas the resolution in k-space is determined by
the size of the sample (the density of the reciprocal lattice).
The temporal Fourier transform of the autocorrelation of time series 
in the <tt>.dsf</tt> file is then computed with the postprocessor 
<a href="util_correl.html#dynsf">dynsf</a>.
The weights of the different atom types, usually the coherent scattering 
length, is given by the parameter <tt>dsf_weight</tt>, which requires
<tt>ntypes</tt> values. The spacial Fourier transform is computed for 
<tt>dsf_nk</tt> series of k-vectors, each of which is given in the 
following format:</p>
<pre>
   dsf_k   k0_x k0_y k0_z   kdir_x kdir_y kdir_z   n
</pre>
<p>
representing the series of k-vectors <tt>k0 + i * kdir, i=0,...,n</tt>.
<tt>dsf_nk</tt> must be specified before any <tt>dsf_k</tt> entry,
and there must be exactly <tt>dsf_nk</tt> such entries. The k-vectors
are given with respect to the reciprocal basis of the box vectors.
</p>
</dd>

<dt><a id="msqd" name="msqd"><b>msqd</b></a></dt>
<dd>
<p>
This option enables the computation of the <b>mean square
displacements</b> (MSQDs) (for each atom type and each direction
separately). It shares its parameters with the option corr. The
computation of the MSQDs is started at step <tt>correl_start</tt>,
and ends at step <tt>correl_end</tt>. The reference positions are
first stored at step <tt>correl_start</tt>, and then they are reset
every <tt>correl_int</tt> steps (or never, if
<tt>correl_int=0</tt>, which is the default). The MSQDs are
computed every <tt>correl_ts</tt> steps between
<tt>correl_start</tt> and <tt>correl_end</tt>, and are written to
the file <tt>&lt;outfiles&gt;.msqd</tt>, preceeded by the current
simulation time. The format of the msqd file is:</p>
<pre>
  time d2x_1 d2y_1 [d2z_1] [d2x_2 d2y_2 [d2z_2]] ...
</pre>
<p>
where <tt>d2x_n</tt> is the mean square displacement of particles
of type <tt>n</tt> in <tt>x</tt> direction, etc. With the options
<tt>msqd_ntypes</tt> (default 1) and <tt>msqd_vtypes</tt> (default
0) you can choose, whether you want mean square displacements for
real types only or for all virtual types separately. If you choose
both options, the leading columns are for real types, the rear ones
are for the virtual types. </p>
<p>
The parameters <tt>correl_start</tt> and <tt>correl_end</tt> can
be used to switch this option on and off during a multiphase
simulation. </p>
</dd>

<dt><a id="corr" name="corr"><b>corr</b></a></dt>
<dd>
<p>
This option enables the computation of the (spherically
averaged) <b>van Hove self-correlation function</b> (VHSCF).</p>
<p>
The computation of the VHSCF is started at step
<tt>correl_start</tt>, and ends at step <tt>correl_end</tt>. Every
<tt>correl_int</tt> steps after <tt>correl_start</tt>, the
correlation histogram is written to files
<tt>&lt;basename&gt;.corr&lt;n&amp;gt.&lt;i&gt;</tt>, where
<tt>&lt;n&gt;</tt> is a running number and <tt>&lt;i&gt;</tt> ist
the atom type. Every <tt>correl_ts</tt> steps, correlation data is
added to the histogram.</p>
<p>
The dimension of the correlation histogram is detemined by the
parameters <tt>correl_tmax</tt> (time direction) and
<tt>correl_rmax</tt> (radial direction). The step width of the
histogram is <tt>correl_ts</tt> in time direction, and (half) the
diagonal of the box, divided by <tt>correl_rmax</tt>, in radial
direction.</p>
<p>
There are several modes for the output format, determined by the
parameter <tt>correl_omode</tt>:</p>
<pre>
 1  for gnuplot files with 1 empty line between blocks
 2  for gnuplot files with 2 empty lines between blocks
 3  for large gnuplot files (fully occupied matrix) with no empty lines
 4  for short files (refer to source for documentation)
    (writes only a short header followed by matrix elements)
</pre>
<p>
The third mode uses a further parameter, <tt>GS_rcut</tt>, which is
a cutoff radius for the data to be written. </p>
<p>
The parameters <tt>correl_start</tt> and <tt>correl_end</tt> can
be used to switch this option on and off during a multiphase
simulation. <b>Beware:</b> in the current implementation, the
histogram is allocated only once at the beginning of the
simulation, and so the dimensions of the histogram must not change
during the simulation!</p>
<p>
<b>Known bugs:</b></p>
<p>
Resetting the reference positions <tt>every correl_int</tt>
steps is fine, but why do we have to write out and clear the
histogram each time?</p>
<p>
The time in the histogram is taken modulo <tt>correl_tmax</tt>,
but the reference positions are not reset, which spoils the whole
histogram, if <tt>correl_tmax &gt; correl_int</tt>!</p>
<p>
Why don't we use a radial cutoff of the histogram right away,
instead of the wiered constuction with the diagonal, which works
only for orthogonal boxes anyway? In any case, it is better not to
compute the parts of the histogram that are not needed, instead of
just not writing them out (parameter GS_rcut)! </p>
</dd>

<dt><a id="disloc" name="disloc"><b>disloc</b></a></dt>
<dd>
<p>
The disloc option enables certain features useful to detect
dislocations in quasicrystals.</p>
<p>
If the disloc option is present, potential energy and position of each 
particle can be compared to reference values. These reference values 
are either read from the configuration file(which then must have a 
correct <a href="header.html#atomheader">header</a>), or set to values 
computed at a certain time step.</p>
<p>
If the parameter <tt>calc_Epot_ref = 0</tt> (default), the 
reference potential energy is read from the column labelled
<tt>Epot_ref</tt> in the configuration file. Otherwise, the 
potential energy at step <tt>reset_Epot_ref</tt> (default 0) 
becomes the reference potential energy.</p>
<p>
Similarly, the reference positions of the particles are set
to the actual positions at step <tt>update_ort_ref</tt>
(default 0). If <tt>update_ort_ref &lt; 0</tt>, the reference
positions must be given in the columns labelled <tt>x_ref</tt>,
<tt>y_ref</tt> and <tt>z_ref</tt> (3D only) in the configuration 
file.</p>
<p>
If the parameter <tt>Epot_diff = 1</tt> (default), the potential 
energy written to <tt>.pic</tt> files 
and to <a href="output.html#distributions">energy distribution
files</a> is the difference of the actual potential energy and the
reference potential energy. This can be switched off by setting
<tt>Epot_diff = 0</tt>.</p>
<p>
If <tt>dem_int &gt; 0</tt>, particles whose potential energy 
deviates from the reference energy by more than <tt>min_dpot</tt>
are written in intervals of <tt>dem_int</tt> to 
<a href="output.html#disloc">differential energy map</a> files. 
Similarly, if <tt>dsp_int &gt; 0</tt>, particles whose squared
displacement from the reference position exceeds <tt>min_dsp2</tt>
are written in intervals of <tt>dsp_int</tt> to 
<a href="output.html#disloc">displacement map</a> files.
The writing of these files can be switched off by setting the
writing intervals to zero.</p>
</dd>

<dt><a id="homdef" name="homdef"><b>homdef</b></a></dt>
<dd>
<p>
If <tt>lindef_interval</tt> is positive, the sample is linearly
deformed every <tt>lindef_interval</tt> steps. The linear deformation
is described by a full deformation matrix <b>A</b>, whose rows are 
given by the scalar <tt>lindef_size</tt> times the vectors
<tt>lindef_x</tt>, <tt>lindef_y</tt>, and <tt>lindef_z</tt> (3d only).
The transformation <b>x</b> -&gt; <b>x</b> + <b>A</b> <b>x</b>
is applied to both the atom positions and the box vectors.
In order to prevent the box contents from just snapping back, 
periodic boundary conditions are required, or boundary layers 
of atoms which are moved during the deformation, but are kept fixed 
otherwise.</p>
<p>
The older interfaces for scale and shear deformations, activated
by the parameters <tt>exp_interval</tt> and <tt>hom_interval</tt>,
are <b>deprecated</b> and should no longer be used.</p>
</dd>

<dt><a id="deform" name="deform"><b>deform</b></a></dt>
<dd>
<p>
The deform option requires <b>free</b> boundary conditions (the
box won't be deformed, but periodic boundary conditions can be
used, e.g. when the deformation is orthogonal to the pbc (use at
own risk, take care of angular momentum). A deform step is performed
if <tt>max_deform_int</tt> is positive, and either the last deform 
step was done <tt>max_deform_int</tt> steps ago, or a 
<a href="ensembles.html#relaxation">relaxation integrator</a> 
is active and the sample is <a href="ensembles.html#relaxcontrol">
sufficiently relaxed</a>. In a deform step, all atoms of virtual type v
are shifted by the <tt>deform_shift</tt> vector for that type v. A
<tt>deform_shift</tt> for type v is specified as follows in the
parameter file:</p>
<pre>
    deform_shift v shift_vector
</pre>
<p>
All shift vectors are additionally multiplied with the scalar
<tt>deform_size</tt>.
During the first <tt>annealsteps</tt> steps, no deformations are
done. This mechanism can be used both for shears
(<tt>deform_shift</tt> parallel to sample boundary) and for
compressions or expansions (<tt>deform_shift</tt> perpendicular to
sample boundary). The atoms with the virtual types concerned are
usually located in two boundary layers of the sample. </p>
<p>
Besides translations of atoms, the option <b>deform</b> also
allows shear transformations of atoms with a common virtual type.
In this case, the additional parameter <tt>deform_shear</tt> has to
be specified in the parameter file in the following format:</p>
<pre>
    deform_shear v shear_vector
</pre>
<p>
The shear transformation is given by </p>

<table align="center" border="0" width="90%" summary="shear formula">
<tr>
<td align="left"><b>x'</b> = <b>x</b> +
<b>s</b>&middot;(<b>x</b>-<b>b</b>) <b>v</b></td>
</tr>
</table>

<p>
where the vector <b>s</b> is determined by <tt>deform_shear</tt>
and <b>v</b> is represented by the parameter <tt>deform_shift</tt>.
<tt>deform_shift</tt>, which should be a unit vector, has now the
meaning of the shear direction. The base point <b>b</b> of the
shear transformation can be specified through the parameter
<tt>deform_base</tt> which is the origin of the simulation box by
default. This point determines the invariant plane of the shear
transformation. <tt>deform_base</tt> has to be given in the
parameter file in the format</p>
<pre>
    deform_base v base_point
</pre>
</dd>

<dt><a id="fbc" name="fbc"><b>fbc</b></a></dt>
<dd>
<p>
This option enables <b>Force Boundary Conditions</b>, 
which are extra forces acting on atoms of certain 
<a href="general.html#virtual">virtual types</a>. 
This is implemented for the nve and nvt ensembles, and for the
<a href="ensembles.html#relaxation">relaxation integrators</a>.
The extra forces are specified by parameters.</p>
<p>
For non-relaxator ensembles (nve and nvt), the extra forces
are linearly interpolated between the values given by the 
parameters <tt>extra_startforce</tt> and <tt>extra_endforce</tt>,
which take a virtual type as the first argument, and the 
components of the extra force vector acting on atoms of that
virtual type as the following arguments. For different virtual
types, different extra forces can be specified. By default,
the extra forces are zero.</p>
<p>
For <a href="ensembles.html#relaxation">relaxation integrators</a>,
the extra forces are specified by the parameters
<tt>extra_startforce</tt> and <tt>extra_dforce</tt> in the
same format. <tt>extra_dforce</tt> specifies a force increment, 
which is added to the applied force whenever the sample is 
<a href="ensembles.html#relaxcontrol">sufficiently relaxed</a>. 
The force increment is also added, if <tt>max_fbc_int > 0</tt>
and the last increment was added more than <tt>max_fbc_int</tt> 
steps ago. After adding the force increment, the relaxation 
continues.</p>
<p>
Note that the parameter <tt>total_types</tt> must be read
<strong>before</strong> any extra forces.</p>
</dd>

<dt><a id="sock" name="sock"><b>sock</b></a></dt>
<dd>
<p>
Provide support for sockets (for visualization). </p>
</dd>

<dt><a id="pair" name="pair"><b>pair</b></a></dt>
<dd>
<p>
Use tabulated pair potentials. This is the default option. Its
only use currently is to enable IMD to employ additional pair
potentials in the options <b>tersoff</b> and <b>ewald</b>. </p>
</dd>

<dt><a id="eam" name="eam"><b>eam</b></a></dt>
<dd>
<p>
<a href="eam.html">Use Embedded Atom Method potentials.</a> </p>
</dd>

<dt><a id="eeam" name="eeam"><b>eeam</b></a></dt>
<dd>
<p>
<a href="eam.html#eeam">Use extended Embedded Atom Method potentials.</a> </p>
</dd>

<dt><a id="covalent" name="covalent">
<b>keating</b>, <b>ttbp</b>, <b>stiweb</b>, <b>tersoff</b>, and <b>tersoff2</b></a></dt>
<dd>
<p>
<a href="covalent.html">Use many-body potentials.</a> </p>
</dd>

<dt><a id="ewald" name="ewald"><b>ewald</b></a></dt>
<dd>
<p>
<a href="ewald.html">Use Coulomb potential with Ewald summation
method.</a> </p>
</dd>

<dt><a id="uniax" name="uniax"><b>uniax</b></a></dt>
<dd>
<p>
<a href="uniax.html">Use Gay-Berne potential for uniaxial
molecules.</a> </p>
</dd>

<dt><a id="pacx" name="pacx"><b>pacx</b></a></dt>
<dd>
<p>
Link with PACX libraries in addition to MPI. Needed for
Metacomputing, but also useful if certain MPI routines are not
available. PACX is an extension of MPI which allows the
distribution of the simulation across a network of (possibly
continent-widely) separated supercomputers.</p>
<p>
IMD uses MPI_Cart routines to set up the communication network
between the PEs. This is not possible with PACX since one
supercomputer sees only the communication nodes of the other and
not its topology. Therefore the MPI_Cart routines have been
replaced.</p>
<p>
The PACX library is available from the PACX-Group at the RUS. A
description of PACX and how to use it can be found 
<a href="http://www.hlrs.de/organization/pds/projects/pacx-mpi/">
here</a>.</p>
</dd>

<dt><a id="shock" name="shock"><b>shock</b></a></dt>
<dd>
<p>
The option shock enables IMD to simulate shock waves. 
The shock wave is generated by setting the velocities of the atoms
in routine imd_maxwell to a constant value <tt>shock_speed</tt>.
The velocity direction is in the positive x-axis.</p>
<p>
There are several modes set by <tt>shock_mode</tt>:</p>

<ul>
<li>If <tt>shock_mode</tt> is set to 1 then the left part of the
sample ("flyer plate or piston") with thickness <tt>shock_strip</tt> is moved
towards the right part ("target").</li>

<li>If <tt>shock_mode</tt> is set to 2 then two halves of the sample are
moved towards oneanother ("symmetric impact method").</li>

<li>If <tt>shock_mode</tt> is set to 3 then the whole sample is moved
against a fixed wall ("momentum mirror method").
If the parameter <tt>shock_incr</tt> is set, then the shock wave velocity is
increased linearly from 0 to the final <tt>shock_speed</tt>.</li>

<li>If <tt>shock_mode</tt> is set to 4 then the sample is compressed by two
mirrors moving at the velocities <tt>shock_speed_left</tt> and
<tt>shock_speed_right</tt>.</li>
</ul>

<p>Up to now, we use a box which is periodic
along the y- and z-axis and has free boundaries in the x-direction. Periodic
boundaries along the x-direction are also possible, but not yet implemented.
They can be realized by abusing hom_def and forgetting to rescaled the sample.

<p><b>Important</b>: Currently, the atom velocities for the
shockwave are set by the routine imd_maxwell, which is called at
the start of the simulation only. It is therefore not possible to
start a shockwave in a later phase of a multiphase simulation.
Therefore, this option is <a href="limitations.html">not multiphase
ready</a>. </p>
</dd>

<dt><a id="laser" name="laser"><b>laser</b></a></dt>
<dd>
<p>
This option incorporates parameters for phenomenological laser heating of
sample surfaces. At the moment, usage of the <b>laser</b> toolbox is 
<a href="limitations.html">not multiphase ready</a>. 
</p>
<p>
The laser option supports three heating modes.
</p>
<p>
The first mode is
instantaneous heating at the beginning of the simulation, which is done by
setting the particle velocity randomly according to a maxwell distribution.
It can be activated by setting the parameter laser_delta_temp to a value greater
than zero, which will be used as the maximum temperature increment at the
surface. 
This is equivalent to using an infinitesimally short laser pulse with a fluence
(surface energy density) of <img align="middle"
				 alt="sigma_e=3/2*rho_n*laser_delta_temp/mu"
				 src="sigma_e_formula.png"></img>, 
with the atom number density <img align="middle" alt="rho_n"
				  src="rho_n_formula.png"></img> and the
absorption constant <img align="middle" alt="mu"
			 src="mu_formula.png"></img>. <img align="middle"
							   alt="\Delta T"
							   src="delta_t_formula.png"></img> 
corresponds to the parameter laser_delta_temp. 
</p>
<p>
The second heating mode works by continuous rescaling of the atomic velocities
after every IMD timestep. The energy gain in a single time step is proportional
to the timestep itself and to a source term, which depends on time t and depth
below the surface x like <img  align="middle" alt="S(x,t)=S_{peak}exp(-\mu
						   x)exp(-(t-t_0)^2/(2\sigma_t^2))"
			       src="S_of_x_and_t_formula.png"></img>, that is,
an exponential decrease in depth with a gaussian time profile. This heating
mode expects the fluence in the parameter laser_sigma_e, the time of maximum
intensity and the width of the gaussian pulse in the parameters laser_t_0 and
laser_sigma_t. To activate this mode, it is enough to assign a value larger
than zero to laser_sigma_e. By integration over time and depth one receives the
relationship <img  align="middle"
		   alt="\sigma_e=S_{peak}sqrt(2\pi\sigma_t^2)/(1-R)\mu"
		   src="sigma_e_rescaling_formula.png"></img>. 
</p>
<p>
The third heating mode works only in conjunction with the TTM-integrator for
simulations with the Two-Temperature-Model. It is automatically activated if
IMD was compiled with the ttm and laser make-options. It works with the same
source term and parameters as the second mode (see above), but the energy is
exclusively added to the electronic subsystem. Of course, some more parameters
are required to configure the <a href="ensembles.html#ttm">ttm
    integrator</a>. To reduce the effects of reflected pressure waves, a
damping module was implemented in IMD
named <a href="#pdecay"><tt>pdecay</tt></a>.
</dd>

<dt><a id="laseryz" name="laseryz"><b>laseryz</b></a></dt>
<dd>
<p>
This option is a modified version of the second heating mode from
the <tt><a href="#laser">laser</a></tt> option.  
In addition to rescaling the atomic velocities, an intensity profile is
applied.  
The intensity profiles are controlled by the parameter <tt>laser_tem_mode</tt>,
which needs three numbers.  
The first number specifies the intensity profile, 0 for Laguerre polynomials
and 1 for Hermite polynomials.  
The two following numbers define order and index of the
polynomial. Example: <tt>laser_tem_mode 1 0 0</tt> gives a profile  
with a Hermite polynomial (the one at the beginning), the two zeros define the
shape of the TEM-mode  (Transversale Electro-Magnetic-Mode).  
To adjust the laser beam relative to the y and z-axis, one has to specify the
parameters <tt>laser_sigma_w_y</tt> and <tt>laser_sigma_w_z</tt>.  
For arguments smaller than 1, the beam will be adjusted relative to the y and
z-length of the irradiated sample (i.e. <tt>laser_sigma_w_y =
    0.5</tt>, <tt>laser_sigma_w_z=0.5</tt> will center the beam).  
Arguments larger than one will give absolute distances relative to the left and
bottom edge. The last parameter which needs to be specified
is <tt>laser_sigma_w0</tt>, the beam waist.  
<p>
laser_offset:
<p>
The density of the sample will be calculated automatically. In order to make
this work, an offset from the laser needs to be introduced. This can be
achieved e.g. with the following awk-script: 
<pre>#!/usr/bin/awk -f
{
if (FNR==3)
	print  $1, $2+30., $3, $4, $5, $6, $7, $8, $9, $10, $11
else if (FNR>8)
	print $1, $2, $3, $4+15., $5, $6, $7, $8, $9, $10, $11
else
	print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
}
</pre>  
Usage: Copy this script in a script file <tt>offset.sh</tt> and make it executable (<tt>chmod a+x offset.sh</tt>). If you copy this script in the directory with a <tt>my_sample.chkpt</tt> file as your starting sample, then typing in a bash:
<pre> 
 ./offset.sh my_sample.chkpt > offset_my_sample.chkpt
</pre> will add 15 &#8491; to the front and back of the sample. The sample for the
simulation start should be now <tt>offset_my_sample.chkpt</tt>. To reduce the effects of refelcted
pressure waves, a damping module was implemented in IMD
named <tt>pdecay</a></tt>.
</p> 
<p>
</dd>

<dt><a id="loadbalance" name="loadbalance"><b>loadbalance</b></a></dt>
<dd>
<p>
This option enables adapative loadbalancing to improve efficiency and can drastically
the simulation runtime of parallel simulations if particles are highly inhomogenous 
distributed inside the simulation domain.
It is based on a modified domain decomposition scheme in which domains do not need to be
uniform nor orthogonal. The domains are adjusted dynamically to balance the computational
load, e.g. the number of particles in a domain.
Typically the loadbalancer is able to balance the load within a range of 5&#37; to 10&#37;,
unless very inhomogeneous or dynamic simulations with a large number of CPUs are performed.
Imbalance is measured as the fraction of number of particles in a domain by the average number
of particles per domain. Thus values larger than one indicate domains with high loads. Typically it
is possible to keep the maximum imbalance below 1.2 or 1.1 with loadbalancing enabled.
A file with the ending .lblog will be created during the simulation, containing the history
of the simulations' imbalance over time if the option is enabled.


</p>
<p>
Parameters:
</p>
<p>
The only parameter that needs to be set to enable loadbalancing is the value of <tt>lb_frequency</tt>. Other parameters are optional and their default values should work in most cases, but can be adjusted if needed.
</p>
<p>
<tt>lb_balancingType</tt>
</p>
<p>
The loadbalancer supports three different models</br>
0 (default):	Domains are allowed to changes their size and shape, but the regular layout of neighboring domains is guaranteed to be unchanged. A domain will exchange information only to the same set of neighboring domains as if the loadbalancer is deactivated. This restriction may prevent optimal balance if each domains holds in average only a few thousand particles. This mode is the standard setting if loadbalancing is used.</br>
1:	The shape of domains is allowed to be distorted more severly to accomodate highly inhomogeneous particle distributions. The number of communication partners is fully dynamic and if necessary, information is exchange with overnext neighbors. This features can improve the balancing in very complicated particle distributions, but causes a larger overhead.</br>
2:	Restricts the load-balancer to use orthogonal domains. The domain interface are kept parellel to the simulation box. Usually this strategy is not recommended, since in many situations it is not able to evenly balance the load between domains.</br>

</p>
<p>
<tt>lb_frequency</tt>
</p>
<p>
Determines after how many simulation time steps the load-balancing is performed, but only 
if the current imbalance is exceeding <tt>lb_maxLoadTolerance</tt>.
This value should be choosen with the dynamic of the system in mind. In simulations where the
particle distribution changes rapidly, it may be necessary to balance every hundred steps,
where in other cases longer intervals may be sufficent.
By default this value is 0 and balancing is disabled, however the modified communication routines are still used (see below)
</p>
<p>
<tt>lb_maxLoadTolerance</tt>
</p>
<p>
Loadbalancing is only performed if the gloabl load imbalance is larger than this tolerance threshold.
The default value is 1.1.
</p>
<p>
<tt>lb_preRuns</tt>
</p>
<p>
Perform a number of load-balance steps before the actual simulation is started. Since this is usually computational inexpensive, a value of 100-200 is recommendable to start from a well balanced configuration.
</p>
<p>
<tt>lb_contractionRate</tt>
</p>
<p>
Controls how quickly the size of domains are adjusted. The default value is equal to the cell size and typically does not need to be modified.
</p>
<p>
<tt>lb_maxLoadToleranceFactorForReset</tt>
</p>
<p>
The loadbalancer may get stuck in a local minumum, resulting in a increasing local imbalance. If the standard balancing procedure cannot compensate this and the imbalance exceeds this second threshold, a more aggressive balancing is performed that partially resets the domain configuration. This can often overcome convergence in a local minimum. The default value is 1.4. In case <tt>lb_balancingType</tt> is set to 2, this value should be set very high.
</p>
<p>
<tt>lb_iterationsPerReset</tt>
</p>
<p>
Defines how many cycles are performed during a partial reset to overcome local convergence. The default is 10 cycles.
</p>
<p>
<tt>lb_minStepsBetweenReset</tt>
</p>
<p>
Defines how often the reset operation is executed. The number defines how many regular loadbalancing operations must be performed before another aggressive reset and balancing is performed.
The default is 0.

<tt>lb_writeStatus</tt></br>
Provides additional information about the loadbalancer configuration.</br>
0 (default): No information besides the .lblog-file is created.</br>
1: After each iteration of loadbalancing a file with the ending .lb is created, describing the shape of all domains. Additionally, checkpoint files contain a value on which CPU the particle is located.</br>
2: The .lb-file contains more information about its state (not recommended)</br>
3: The .lb-file contains much much more information about its state (not recommended at all)
</p>
<p>
Limitations:
</p>
<p>
The loadbalancer is only applicable in three-dimensional MPI parallel simulations and the number of CPUs in
periodic dimensions must be a multiple of two.
Furthermore, it is currently not possible to combine the loadbalancer with features that 
resize the simulation box, e.g. NPT or DEFORM. Simulations using non-orthognal boxes are 
supported, but are not well tested. Mixed OpenMP/MPI have not been tested as well, but are supposed to work.
</p>

<p>
Communications between domains during loadbalancing:
</p>
<p>
The loadbalancer algorithm uses a different communication strategy to exchange information
between CPUs. Instead of using the Plimpton-scheme, where messages are send only to six adjacent
neighbor domains and forwarded over corners, messages are exchanged directly with all neighboring 
domains if load-balancing is enabled. Depending on the bandwidth and latencies of the interconnection
between computing nodes, this approach may or may not be faster than the Plimpton scheme.
There is the possibility that simulations run slightly faster using the direct communication
even if the balancing itself is disabled by setting <tt>lb_frequency</tt> to 0.
</p>
</dd>

<dt><a id="sm" name="sm"><b>sm</b></a></dt>
<dd>
<p>
This option based on the model of Streitz and Mintmire (Phys. Rev. B <B>50</B>,
11996 (1994)) enables IMD to compute the charges of a metal/metal-oxide system. 
The valencies are determined by minimization of the electrostatic energy, which
is given by the expression 
<center>
<img  align="middle"
      alt="E_{\text{es}}=E_{0}+\sum_{i}^{N}\chi_{i}q_{i}+\frac{1}{2}\sum_{i,j}^{N}\widetilde{V}_{ij}q_{i}q_{j}"
      src="electrostatic_energy.png"></img>. 
</center></p>
<img align="middle" alt="E_{0}"
     src="E_0.png"></img> strictly depends on nuclear coordinates and is of no
consequence for the minimization, while
<center>
<img  align="middle" 
      alt="\chi_{i}=\chi^{0}_{i}+\sum_{\substack{j\neq i}}^{N} Z_{j}\big\lbrace\!\left[j|f_{i}\right]-\left[f_{i}|f_{j}\right]\!\big\rbrace"
      src="electronegativity.png"></img>,
</center></p>
specifies the electronegativity of each atom <img  align="i" src="i.png"></img>
and 
<center>
<img  align="middle" 
      alt="\widetilde{V}_{ij}=\left\{\begin{array}{cl}J_{i}^{0}, & i=j \\ \left[f_{i}|f_{j}\right], & i \neq j\end{array}\right." 
      src="electrostatic_matrix.png"></img>,
</center></p>
the electrostatic interaction matrix with the atomic hardness or self-Coulomb
repulsion <img align="middle" alt="J_{i}^{0}" src="J_0.png"></img>. The terms  
<center>
<img  align="middle"
      alt="\left[j|f_{i}\right]=\int\!\mathrm{d}^{3}r_{1}\,\frac{f_{i}\left(\ve{r}_{1}-\ve{r}_{i}\right)}{\left|\ve{r}_{1}-\ve{r}_{i}\right|}" 
      src="na_pot.png"></img>, 
</center></p>
and 
<center>
<img  align="middle"
      alt="\left[f_{i}|f_{j}\right]=\int\!\mathrm{d}^{3}r_{1}\!\int\!\mathrm{d}^{3}r_{2}\,\frac{f_{i}\left(\ve{r}_{1}-\ve{r}_{i}\right)f_{j}\left(\ve{r}_{2}-\ve{r}_{j}\right)}{r_{12}}"
      src="cr_pot.png"></img>, 
</center></p>  
are the nuclear attraction potential and the Coulomb repulsive potential,
depending on the atomic-density distribution
<img  align="middle"
      alt="f_{i}\left(\left|\ve{r}-\ve{r}_{i}\right|\right)=\frac{\zeta_{i}^{3}}{\pi}e^{-2\zeta_{i}\left|\ve{r}-\ve{r}_{i}\right|}"
      src="atomic_density_distrib.png"></img> (Slater 1s orbital). For a detail
examination of such integrals see Roothaan (J. Chem. Phys. <B>19</B>, 1445
(1951)). Both 
contain one <img  align="middle" alt="1/r" src="1_r.png"></img> long-range term,
which is evaluated in the origin work of Streitz and Mintmire by the standard
Ewald technique. For the computation in IMD also the Wolf summation method (J. Chem. Phys.,
110(17):8254-8282, 1999) is applied. The
values of <img  align="middle" alt="q_i" src="q_i.png"></img>  are chosen 
as those that minimize <img  align="middle" alt="E_{\text{es}}"
			     src="E_es.png"></img>. This is the equivalent of
solving the system    
<center>
<img  align="middle" alt="\sum_{j}^{N}\widetilde{V}_{ij}q_{j}=\mu-\chi_{i}"
      src="LGS.png"></img>, 
</center></p>
subject to the constraint of net-charge neutrality <img  align="middle"
							 alt="\sum_{i}^{N}q_{i}=0" 
							 src="net_charge_neutrality.png"></img>. The 
chemical potential <img  align="middle" alt="\mu=\mu_{i}\equiv\frac{\partial
  E_{\text{es}}}{\partial q_{i}}" src="chemical_pot.png"></img> follows from
the electronegativity equalization 
condition. Including the constraint of net-charge neutrality, above equation
can be either splitted into two systems of linear equations:
<center>
<img  align="middle" alt="\sum_{j}^{N}\widetilde{V}_{ij}s_{j}=-\chi_{i}"
      src="LGS_split_1.png"></img> and <img  align="middle"
					     alt="\sum_{j}^{N}\widetilde{V}_{ij}t_{j}=-1" 
					     src="LGS_split_2.png">,
</center></p>
with <img  align="middle" alt="\mu=\frac{\sum_{i}^{N}s_{i}}{\sum_{i}^{N}t_{i}}"
	   src="chemical_pot_2.png"></img> and <img  align="middle"
						     alt="q_{i}=s_{i}-\mu
							  t_{i}"
						     src="charges.png"></img>,
or can be written via block matrix notation as
<center>
<img  align="middle" alt="\begin{pmatrix} \mathbf{\widetilde{V}} & \ve{C} \\ 
\ve{C}^{t} & 0\end{pmatrix}\begin{pmatrix}\ve{q}\\-\mu\end{pmatrix}=\begin{pmatrix}-\vegr{\chi}\\0\end{pmatrix}"
      src="LGS_full.png"></img>.  
</center></p>    
See Modelling Simul. Mater. Sci. Eng. <B>16</B>, 025006 (2008). The block vector <img  align="middle" alt="\ve{C}"
			     src="C_vector.png"></img> has all elements equal
to unity. In IMD both versions are implemented and for both a conjugate
gradient solver is applied. 
</p>
From the electrostatic energy <img  align="middle" alt="E_{\text{es}}"
			     src="E_es.png"></img> additional force
contributions result:
 <center>
<img  align="middle" alt="\ve{F}_{\text{es}}=-\nabla E_{\text{es}}"
      src="Force_electrostatic.png"></img>. 
</center></p>
<p>
Implemented by Andreas Chatzopoulos, Johannes Roth and Franz G&auml;hler.     
</dd>

<dt><a id="transport" name="transport"><b>transport (nvx)</b></a></dt>
<dd>
<p>
This option enables IMD to compute the heat conductivity of a
sample. It is automatically activated by the <a
href="ensembles.html#nvx">nvx ensemble</a>. The sample is divided
into <tt>tran_nlayers</tt> layers. The temperature of layer 0 is
initialized to <tt>starttemp + dTemp_start</tt>, and linearly moved
to <tt>starttemp + dTemp_end</tt> during the simulation. Similarly,
the temperature of layer <tt>tran_nlayers/2</tt> (in the middle of
the sample) is initially set to <tt>starttemp - dTemp_start</tt>,
and linearly moved to <tt>starttemp - dTemp_end</tt>. The time, the
heat conductivity, and the temperatures in layers 0 to
<tt>tran_nlayers/2</tt> is written to the file
<tt>&lt;basename&gt;.tempdist</tt> every <tt>tran_interval</tt>
steps. </p>
</dd>

<dt><a id="stress_tens" name="stress_tens"><b>stress</b></a></dt>
<dd>
<p>
The option stress enables the computation of the stress or
pressure tensor. This is a non-negligible extra effort, and should
be done only when the pressure distribution or the pressure tensor
is needed. The global, scalar pressure is always computed. If the
option stress is enabled, the components of the global pressure
tensor are written to the <a
href="output.html#properties">properties file</a> every
<tt>eng_int</tt> time steps. It is also possible to write out <a
href="output.html#distributions">distributions</a> of the scalar or
tensorial pressure, and to write out the pressure tensor
contribution of each atom every <tt>press_int</tt> time steps, by
setting the <tt>press_int</tt> parameter to a positive value.</p>
</dd>

<dt><a id="fnorm" name="fnorm"><b>fnorm</b></a></dt>
<dd>
<p>
Writes the average of the modulus of a (random) force component
to the <tt>.eng</tt> file. This should be a good measure for the
degree of relaxation in a <a href="ensembles.html#relaxation">
relaxation simulation</a>. </p>
</dd>

<dt><a id="einstein" name="einstein"><b>einstein</b></a></dt> 
<dd>
<p>
Writes the Einstein frequency to the <tt>.eng</tt> file. This
value can be used as <tt>inv_tau_eta</tt> for a Nose-Hoover
thermostat. This option is supported in NVE, NVT and NPT
simulations only. </p>
</dd>

<dt><a id="efilter" name="efilter"><b>efilter</b></a></dt>
<dd>
<p>
Only those atoms (no virtual atoms) which have a potential
energy between e_pot_lower and e_pot_upper (must be specified for
all ntypes) are written in <tt>&lt;outfile&gt;.ef.&lt;n&gt;</tt>,
where <tt>&lt;n&gt;</tt> is a running number. This happens every
ef_checkpt_int step. </p>
</dd>

<dt><a id="fefl" name="fefl"><b>fefl</b></a></dt> 
<dd>
<p>
Option for free energy simulations using the Frenkel-Ladd method
(J. Chem. Phys. <B>81</B> (1984) 3188).
Runs a simulation where the native interaction (lambda=0) can be switched to an
Einstein crystal (lambda=1) with harmonic springs between the initial and the
current atom positions. Implemented by Johannes Roth. 

</dd>

<dt><a id="writef" name="writef"><b>writef</b></a></dt>
<dd>
<p>
If <tt>force_int &gt; 0</tt>, the forces on atoms are written 
every <tt>force_int</tt> steps into the file 
<tt>&lt;outfile&gt;.wf.&lt;n&gt;</tt>, where <tt>&lt;n&gt;</tt> 
is a running number. If <tt>force_all = 0</tt>, only the forces of 
atoms whose virtual type differs from the real type are written 
(default); otherwise, the forces of all atoms are written. </p>
</dd>

<dt><a id="avpos" name="avpos"><b>avpos</b></a></dt>
<dd>
<p>
This option enables IMD to compute the average position of the
atoms during a time interval. The averaging begins at step
<tt>avpos_start</tt> (default 0) and ends at step
<tt>avpos_end</tt> (default <tt>maxsteps</tt>). Every
<tt>avpos_int</tt> steps, the averaged positions are written in an
output file <tt>&lt;outfile&gt;.&lt;n&gt;.avp</tt>. The output file
further contains the average potential energy of the atoms. After
writing the output, the averaging begins with the actual atom
positions. The number of steps between additions of coordinates is
specified by the parameter <tt>avpos_res</tt>. For each avpos
output file, an avpos iteration file is written which has the name
<tt>&lt;outfile&gt;.&lt;n&gt;.avp.itr</tt> and contains the actual
box vectors. When an NPT ensemble is used, the averaged box vectors
are written in this file. </p>
</dd>

<dt><a id="quasi" name="quasi"><b>quasi</b></a></dt>
<dd>
<p>
This option is required for the generation of truncated
icosahedra quasicrystals, one of the few structure types IMD can 
<a href="config.html#generated">generate itself</a>. </p>
</dd>

<dt><a id="nnbr" name="nnbr"><b>nnbr</b></a></dt>
<dd>
<p>
Compute coordination numbers. The cutoff radius for neighbor
counting is atom type dependent: counted as a neighbor of an 
atom of type i are those atoms of type j, which are within a 
cutoff radius r_ij. The cutoff radii must be specified as a 
ntypes<sup>2</sup>-dimensional vector <tt>nb_rcut</tt>in the 
parameter file.
</p>

<dt><a id="ordpar" name="ordpar"><b>ordpar</b></a></dt>
<dd>
<p>
Compute order parameter closely related to the potential energy. 
This option is mainly useful for two-dimensional binary tiling 
quasicrystals. In quasicrystals the potential energy of atoms of 
the same type can be quite different, depending on their neighbourhood, 
so that defects can be hard to detect. The order parameter - which is 
printed in the output files in place of the potential energy - narrows 
the potential energy distribution and improves the visibility of
defects.</p>
<p>
Only atoms within a sphere of a certain radius which is
specified in the ntypes<sup>2</sup>-dimensional vector
<tt>op_rcut</tt> contribute to the order parameter: their 
potential energy, weighted by the number specified in the
ntypes<sup>2</sup>-dimensional vector <tt>op_weight</tt> is 
added up.</p>
<p>
Two-dimensional binary tiling quasicrystals obey in their 
ground state a linear relation in the numbers of neighbors. 
With the choice</p>
<pre>
   op_rcut    1.50 1.25 1.25 0.85
   op_weight  1.00 0.25 0.50 1.00
</pre>
<p>
all atoms will then have the same value of the order parameter
in the ground state, and defects become visible through deviations 
from this value. In three dimensions, such a simple relation usually 
doesn't exist. 
</p>
</dd>
<dt><a id="pdecay" name="pdecay"><b>pdecay</b></a></dt>
<dd>
<p>
This option allows the damping of pressure waves, which are reflected at the
back of the sample. It is usually used together with
the <a href="#laser">laser</a> or  
<a href="#laseryz">laseryz</a> modules.
Four different modes exist. A mode is set via <tt>pdecay_mode</tt>, so that
e.g. <tt>pdecay_mode 2</tt> sets mode 2. Mode 0 linearly scales down the
momenta of the atoms, mode 1 is a quadratic scale down of the momenta. The
modes 2 and 3 add a friction part to the forces. Mode 2 in a linear and mode 3
in a quadratic fashion. The value <tt>xipdecay</tt> is a constant friction
parameter, that has to be specified for mode 2 and 3. The damping zone can be
specified via the parameter <tt>ramp_fraction</tt>. The possible values
for <tt>ramp_fraction</tt> are between <tt>0</tt> and <tt>0.9</tt>. They define
the damping range relative to the sample size. A <tt>ramp_fraction</tt> of
e.g. <tt>0.4</tt> will create a damping ramp with a size of 40% of the sample's
length, starting at the back.  
<pre>Usage example: 
 
xipdecay 4.0
pdecay_mode 2
ramp_fraction 0.4</pre>

</p>
</dd>

<dt><a id="atdist" name="atdist"><b>atdist</b></a></dt>
<dd>
<p>
Determines the time-averaged distribution of atoms in a
<b>rectangular</b> block of material between the lower left corner
<tt>atdist_ll</tt> and the upper right corner <tt>atdist_ur</tt>.
For this purpose, the block is divided into a rectangular array of
bins, of dimension <tt>atdist_dim</tt>. Each bin contains a counter
for each atom type, and every <tt>atdist_int</tt> time steps such a
counter is incremented if an atom of the given type is located in
that bin. This recording is started at time step
<tt>atdist_start</tt>, and stopped at time step
<tt>atdist_end</tt>. Small samples can be periodically extended in
order to fill a large enough block, using the parameters
<tt>atdist_per_ll</tt> and <tt>atdist_per_ur</tt>, which are
integer vectors specifying the lower left and upper right corners,
respectively, of the the periodic array of copies of the sample. It
is the user's responsibility to choose this array large enough. The
parameter <tt>atdist_phi</tt>, which is given in multiples of 2 Pi,
can be used to rotate the sample around the z-axis, before it is
mapped to the array of bins. Furthermore, the positions and types
of all atoms in the block are written every <tt>atdist_pos_int</tt>
time steps to files *.cpt, which can be used for visualization with
the Covise program. The resulting distribution files *.atdist can
be analysed and converted with the utility program <a
href="util_distrib.html#atdist">atdist</a>.</p>
<p>
This option is parallelized only by OpenMP, not by MPI.</p>
</dd>

<dt><a id="diffpat" name="diffpat"><b>diffpat</b></a></dt>
<dd>
<p>
Determines the diffraction pattern of a <b>rectangular</b> block
of material between the lower left corner <tt>diffpat_ll</tt> and
the upper right corner <tt>diffpat_ur</tt> by Fast Fourier
Transform (FFT). For this purpose, the block is divided into an
array of bins, of dimension <tt>diffpat_dim</tt>. Each bin contains
a counter for each atom type, and every time step such a counter is
incremented if an atom of the given type is located in that bin.
Every <tt>diffpat_int</tt> time steps, the FFT of the resulting
distrbution is computed, its intensities are added up, and the
array is cleared. In other words, the contributions of time slices
of <tt>diffpat_int</tt> steps are added up incoherently. The
recording of the diffraction pattern is started at time step
<tt>diffpat_start</tt>, and stopped at time step
<tt>diffpat_end</tt>. The scattering strength of the different
atoms types, usually propotional to the charge of the nucleus, must
be given with the parameter <tt>diffpat_weight</tt>.</p>
<p>
Note that the resulution of the diffraction pattern (the size of
its pixels) is inversely proportional to the size of the block of
material, whereas the dimension of the distribution array
determines the range of reciprocal space for which the diffraction
pattern is computed. Unlike to option <a href="#adist">atdist</a>,
the sample is not periodically extended in order to fill the block.
The resulting diffraction pattern files *.diffpat can be analysed
and converted with the utility program <a
href="util_distrib.html#diffpat">diffpat</a>.</p>
<p>
This option is parallelized only by OpenMP, not by MPI. It also
requires the <a href="http://www.fftw.org">FFTW</a> library, whose
location must be configured in the Makefile.</p>
</dd>

<dt><a id="ada" name="ada"><b>ada</b></a></dt>
<dd>

<p>
	This option enables IMD to perform the Angular-Deviation Analysis
	(ADA) during a simulation. The ADA value is added in each chkpt-file
	and every ada_write_int steps into a <outfiles>.<n>.ada file. The
	cutoff radius to identify nearest neighbors is either given as
	ada_nbr_rcut or by ada_latticeConst. The parameter
	ada_crystal_structure offers three different characterization schemes 
</p>

<p>
	ackland: Characterization according to Ackland & Jones Phys.Rev.B 73
	054104 (2006), except that the nearest neighbor cutoff radius is
	constant

<p>
<pre>
	Types:  ada=0: bcc
		ada=1: fcc (not written to .ada-files)
		ada=2: hcp
		ada=3: unassigned
		ada=4: unknown (usually surface)
</pre>
<p>

<pre>
	fcc: Modified scheme to identify defects in fcc crystals (extended
		pattern as published in Begau et al. Acta Materialia 59 (2011)
		934-942) 
		ada=0: bcc
		ada=1: fcc (not written to .ada-files)
		ada=2: hcp
		ada=3: 12 neighbors, not fcc/hcp
		ada=4: less than 12 neighbors
		ada=5: more than 12 neighbors
		ada=6: less than 10 neighbors
		ada=7: more than 14 neighbors
</pre>
<p>
<pre>

	bcc: Modified scheme to identify defects in bcc crystals 
		ada=0: bcc (not written to .ada-files)
		ada=1: fcc
		ada=2: hcp
		ada=3: 14 neighbors, not bcc
		ada=4: 12-13 neighbors
		ada=5: 15 neighbors
		ada=6: less than 11 neighbors
		ada=7: unknown
</pre>
<p>


</dd>


<dt><a id="nye" name="nye"><b>nye</b></a></dt>

<dd>

<p>
	This option enables IMD to perform a Nye tensor analysis during a
	simulation to numerically compute an approximation of he dislocation
	Burgers vectors and the dislocation line-direction as published in
	Begau et al. JMPS 60 (2012) 711-722. 
	Atomatically ativates the option ada as well.
	For each atom classified as a defect, a pair of a (resultant) Burgers
	vector and a line direction/line sense vector is computed and added to
	the .chkpt and .ada-files. 
	Both vectors are outputted in cartesian coordinates and not in crystal
	coordinates. The Nye tensor analysis only works correctly in single
	crystals. 
	In .ada-files a compressed output format is used. If no Burgers vector
	exists at one atom the column "rbv_data" consists only of the value
	"0", if a Burgers vector is found, the output value is "1" followed by
	six values defining the line-direction and the resultant Burgers
	vector. 
</p>
	

</dd>

<dt><a id="monolj" name="monolj"><b>monolj</b></a></dt>
<dd>
<p>
Monoatomic Lennard-Jones system. The masses are all set to 1,
and particles have no number. All this saves space, which is useful
for world records.</p>
<p>
<b>Editor's remark:</b> Part of this could also be achieved by
using only one mass variable per atom type, instead of one per
atom. </p>
</dd>

<dt><a id="mono" name="mono"><b>mono</b></a></dt>
<dd>
<p>
Special version for one atom type. Hard coding of the number of 
different atom types makes IMD faster. </p>
</dd>

<dt><a id="single" name="single"><b>single</b></a></dt>
<dd>
<p>
Do everything with single precision (default is double precision). 
This saves space, which is useful for world records. </p>
</dd>

<dt><a id="fourpoint" name="fourpoint"><b>4point</b></a></dt>
<dd>
<p>
Imd uses by default a 3-point Lagrange interpolation to
determine the interaction energy and the forces. This option
switches to a 4-point Lagrange interpolation. </p>
</dd>

<dt><a id="hpo" name="hpo"><b>hpo</b></a></dt>
<dd>
<p>
The output is written with a higher precision. </p>
</dd>

<dt><a id="debug" name="debug"><b>debug</b></a></dt>
<dd>
<p>
Compile with debug flags. </p>
</dd>

<dt><a id="timing" name="timing"><b>timing</b></a></dt>
<dd>
<p>
This option gives an idea how much time is spent in IO. </p>
</dd> 

<dt><a id="prof" name="prof"><b>prof</b></a></dt>
<dd>
<p>
Compile with profiling support. </p>
</dd>

<dt><a id="epitax" name="epitax"><b>epitax</b></a></dt>
<dd>
<p>
This option enables the simulation of vacuum deposition of
atoms. For more details take a look at the description of the 
<a href="epitax.html">EPITAX implementation</a>. </p>
</dd>

<dt><a id="ep" name="ep"><b>ep</b></a></dt>
<dd>
<p>
This option permits the application of an external potential. I.e. it can be
used to simulate and indentor. See Ju Li, Phys. Rev. <B>B</B> 67 (2003) 104105
</p>
</dd>

<dt><a id="neb" name="neb"><b>neb</b></a></dt>
<dd>
<p>
This method can be used to calculate reaction pathways by the nudge elastic
band method (NEB). Currently, this option requires one CPU per image. The number of images is provided by the parameter 
neb_nrep. The file names of the images are then coordname.0 - coordname.[neb_nrep-1]. NEB uses the minimization scheme provided by the ensemble, e.g. FIRE. NEB requires as further input parameter a spring constant neb_k. 
The MEP should not depend on the value of neb_k, but the convergence behavior does. The neb_k should scale like one over the time step squared.
Variable spring constants can be used by specifying neb_vark_start and neb_kmax and neb_kmin. Climbing image NEB is used when neb_cineb_start and 
neb_climbing_image are specified.
</p>
</dd>

<dt><a id="rnemd" name="rnemd"><b>rnemd</b></a></dt>
<dd>
<p>
Option for computing transport properties by the M&uuml;ller-Plathe
non-equilibrium exchange method, see
J. Chem. Phys. <b>106</b> (1997) 6082.
</p>
</dd>


<dt><a id="viscous" name="viscous"><b>viscous</b></a></dt>
<dd>
<p>
Enables viscous damping. Every timestep the velocities are reduced proportional to a friction coefficient.
This friction coefficient can be defined either equally for all atoms by the parameter <tt>viscous_friction</tt>.
Alternatively, the value can be defined per atom in a column <tt>viscous_fric</tt>.
The value of this coefficient determines how fast the velocities are reduced, e.g. a value of 1 would eliminate an initial velocity in one unit of simulation time completely.
Currently this option is only available as an option for NVE and MIK/GLOK and this option is automatically activated if the Langevin thermostat is used.
If no other thermostat (Berendsen or Anderson) is activated, this option will continuously reduce the temperature of the system. Thus it could be used to minimize energies as well.
</p>
</dd>

<dt><a id="zapp" name="zapp"><b>zapp</b></a></dt>
<dd>
<p>
removes the net momentum, assuming equal masses.</p>
</dd>

<dt><a id="clone" name="clone"><b>clone</b></a></dt>
<dd>
<p>
The purpose of this option is to work with a two-dimensional system with two
degrees of freedom, but the computation runs in three-dimensions. The
3*r_cut-condition for minimal cell size is establihed by "cloned" atoms which
move exactly as their parents do. 
</p>
</dd>

</dl>

{% include imdfoot.html %}

